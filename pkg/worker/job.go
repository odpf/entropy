package worker

//go:generate mockery --name=JobQueue -r --case underscore --with-expecter --structname JobQueue --filename=job_queue.go --output=./mocks

import (
	"context"
	"errors"
	"fmt"
	"strings"
	"time"
)

const ctxCancellationBackoff = 3 * time.Second

const (
	StatusDone    = "DONE"
	StatusPanic   = "PANIC"
	StatusFailed  = "FAILED"
	StatusPending = "PENDING"
)

// Job represents the specification for async processing and also maintains
// the progress so far.
type Job struct {
	ID        string    `json:"id"`
	Kind      string    `json:"kind"`
	Status    string    `json:"status"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
	RunAt     time.Time `json:"run_at"`
	Payload   []byte    `json:"payload"`

	// Result generated by job execution.
	Result        []byte    `json:"result,omitempty"`
	AttemptsDone  int64     `json:"attempts_done"`
	LastAttemptAt time.Time `json:"last_attempt_at,omitempty"`
	LastError     string    `json:"last_error,omitempty"`
}

// JobQueue represents a special queue that holds jobs and releases them via
// Dequeue() only after their ReadyAt time.
type JobQueue interface {
	// Enqueue all jobs. Enqueue must ensure all-or-nothing behaviour.
	// Jobs with zero-value or historical value for ReadyAt must be
	// executed immediately.
	Enqueue(ctx context.Context, jobs ...Job) error

	// Dequeue one job having one of the given kinds and invoke `fn`.
	// The job should be 'locked' until `fn` returns. Refer JobFn.
	Dequeue(ctx context.Context, kinds []string, fn JobFn) error
}

// JobFn is invoked by the JobQueue for ready jobs. If it returns no error,
// job will be marked with StatusDone by the JobQueue. If it returns error
// job should be retried or marked with StatusFailed accordingly.
// Refer RetryableError for expected behaviour on error.
type JobFn func(ctx context.Context, job Job) ([]byte, error)

func (j *Job) Sanitise() error {
	now := time.Now()

	j.ID = strings.TrimSpace(j.ID)
	j.Kind = strings.TrimSpace(strings.ToLower(j.Kind))

	if j.ID == "" {
		return fmt.Errorf("%w: job id must be set", ErrInvalidJob)
	}

	if j.Kind == "" {
		return fmt.Errorf("%w: job kind must be set", ErrInvalidJob)
	}

	j.Status = StatusPending
	j.CreatedAt = now
	j.UpdatedAt = now

	if j.RunAt.IsZero() {
		j.RunAt = now
	}

	j.AttemptsDone = 0
	j.LastAttemptAt = time.Time{}
	j.LastError = ""
	return nil
}

func (j *Job) Attempt(ctx context.Context, now time.Time, fn JobFn) {
	defer func() {
		if v := recover(); v != nil {
			j.LastError = fmt.Sprintf("panic: %v", v)
			j.Status = StatusPanic
		}

		j.AttemptsDone++
		j.LastAttemptAt = now
		j.UpdatedAt = now
	}()

	select {
	case <-ctx.Done():
		j.Status = StatusPending
		j.RunAt = now.Add(ctxCancellationBackoff)
		j.LastError = fmt.Sprintf("cancelled: %v", ctx.Err())

	default:
		res, err := fn(ctx, *j)
		if err != nil {
			re := &RetryableError{}
			if errors.As(err, &re) {
				j.LastError = re.Error()
				j.RunAt = now.Add(re.RetryAfter)
				j.Status = StatusPending
			} else {
				j.LastError = err.Error()
				j.Status = StatusFailed
			}
		} else {
			j.Result = res
			j.Status = StatusDone
		}
	}
}
